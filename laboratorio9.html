
<!DOCTYPE html>

<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Laboratorio 9 : Metodi Iterativi Stazionari per Sistemi Lineari &#8212; Calcolo Numerico - Esercitazioni di Laboratorio</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Indice" href="genindex.html" />
    <link rel="search" title="Cerca" href="search.html" />
    <link rel="next" title="Laboratorio 10a : Il Metodo di Bisezione" href="laboratorio10.html" />
    <link rel="prev" title="Laboratorio 8 : Il Problema Lineare dei Minimi Quadrati" href="laboratorio8.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="it">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Calcolo Numerico - Esercitazioni di Laboratorio</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Calcolo Numerico - Esercitazioni di Laboratorio
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio1.html">
   Laboratorio 1 : Introduzione a MATLAB
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio2.html">
   Laboratorio 2 : Introduzione a MATLAB - II
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio3.html">
   Laboratorio 3 : L’Aritmetica di Precisione Finita
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio4.html">
   Laboratorio 4 e 5: Metodi di Interpolazione
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio5.html">
   Laboratorio 6 : Metodi di Quadratura
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio6.html">
   Laboratorio 7a : Soluzione di Sistemi Lineari Triangolari
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio7.html">
   Laboratorio 7b : Il Metodo di Eliminazione di Gauss e la Fattorizzazione LU
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio8.html">
   Laboratorio 8 : Il Problema Lineare dei Minimi Quadrati
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Laboratorio 9 : Metodi Iterativi Stazionari per Sistemi Lineari
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio10.html">
   Laboratorio 10a : Il Metodo di Bisezione
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio11.html">
   Laboratorio 10b : Il Metodo di Newton
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio12.html">
   Laboratorio 11 : Metodi per la Soluzione di ODE
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/Cirdans-Home/ingencn"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/Cirdans-Home/ingencn/issues/new?title=Issue%20on%20page%20%2Flaboratorio9.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/laboratorio9.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodi-di-tipo-stazionario">
   Metodi di tipo stazionario
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodo-di-jacobi">
   Metodo di Jacobi
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodo-di-gauss-seidel">
   Metodo di Gauss-Seidel
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#paragone-tra-i-due-metodi-e-velocita-di-convergenza">
   Paragone tra i due metodi e velocità di convergenza
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Laboratorio 9 : Metodi Iterativi Stazionari per Sistemi Lineari</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodi-di-tipo-stazionario">
   Metodi di tipo stazionario
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodo-di-jacobi">
   Metodo di Jacobi
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodo-di-gauss-seidel">
   Metodo di Gauss-Seidel
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#paragone-tra-i-due-metodi-e-velocita-di-convergenza">
   Paragone tra i due metodi e velocità di convergenza
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="laboratorio-9-metodi-iterativi-stazionari-per-sistemi-lineari">
<h1>Laboratorio 9 : Metodi Iterativi Stazionari per Sistemi Lineari<a class="headerlink" href="#laboratorio-9-metodi-iterativi-stazionari-per-sistemi-lineari" title="Link a questa intestazione">#</a></h1>
<p>Un <strong>metodo iterativo</strong> è una procedura matematica che a partire da un <em>valore iniziale</em> genera una sequenza di <em>soluzioni approssimate</em> migliorative, in cui l’approssimazione <span class="math notranslate nohighlight">\(n\)</span>-esima è derivata dalle precedenti.</p>
<p>In questo laboratorio vogliamo concentrarci sulla costruzione di alcuni
metodi di questo tipo per la soluzione di sistemi lineari.</p>
<p>La prima domanda che è legittimo porsi è perché mai vogliamo mettere in piedi
dei metodi iterativi se abbiamo già dei metodi diretti che possono raggiungere
la soluzione del problema cercato?</p>
<ul class="simple">
<li><p>A patto di richiedere una tolleranza minore (spesso sufficiente nelle applicazioni) sull’errore commesso sulla soluzione hanno un costo computazionale inferiore alle controparti dirette.</p></li>
<li><p>Per le dimensioni dei problemi che si vogliono affrontare nelle applicazioni ingegneristiche attuali sono spesso l’unica opzione disponibile (problemi di fluidodinamica computazionale, combustione, meccanica del continuo, …).</p></li>
</ul>
<section id="metodi-di-tipo-stazionario">
<h2>Metodi di tipo stazionario<a class="headerlink" href="#metodi-di-tipo-stazionario" title="Link a questa intestazione">#</a></h2>
<p>Dato un sistema lineare della forma</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \mathbf{b}, \qquad A \in \mathbb{R}^{n \times n},\; \mathbf{x},\mathbf{b} \in \mathbb{R}^n\]</div>
<p>siamo interessati a <strong>metodi di punto fisso</strong> basati su una decomposizione additiva della matrice <span class="math notranslate nohighlight">\(A\)</span> della forma</p>
<div class="math notranslate nohighlight">
\[A = M - N, \qquad\text{ con }\qquad \det(M) \neq 0.\]</div>
<p>Da questa decomposizione si ottiene poi l’iterata di punto fisso come</p>
<div class="math notranslate nohighlight">
\[\begin{split}A \mathbf{x} = \mathbf{b} \Rightarrow (M - N) \mathbf{x} = \mathbf{b} \Rightarrow M \mathbf{x} = N \mathbf{x} + \mathbf{b} \\
\mathbf{x} = M^{-1} N \mathbf{x} + M^{-1} \mathbf{b}\end{split}\]</div>
<p>e quindi</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{x}^{(k+1)} = M^{-1} N \mathbf{x}^{(k)} + M^{-1} \mathbf{b}, \quad k = 0,1,2,\ldots, \\
\mathbf{x}^{(0)} \text{ assegnato}.\end{split}\]</div>
<p>Essendo questa un’iterata di punto fisso, la sua convergenza dipende dall’essere una <strong>procedura contrattiva</strong>, avete dimostrato a lezione che questo è equivalente alla richiesta che il <em>raggio spettrale</em> della matrice di iterazione <span class="math notranslate nohighlight">\(M^{-1}N\)</span> sia strettamente minore di <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="math notranslate nohighlight">
\[\rho(M^{-1}N) = \max_{i=1,\ldots,n}|\lambda_i(M^{-1}N)| &lt; 1.\]</div>
<!---
### Metodi per il calcolo agli autovalori implementati in MATLAB

In alcuni casi data una matrice $A$ e uno splitting $A = M - N$ è possibile calcolare il *raggio spettrale* carta e penna, oppure inferire le proprietà di convergenza del metodo dalle proprietà della matrice $A$ e della particolare forma dello splitting. Laddove questo non fosse possibile, o volessimo una stima più precisa di quello che sta accadendo, dobbiamo ricorrere a dei metodi numerici a questo scopo. La loro costruzione è al di fuori degli obiettivi di questo corso, tuttavia MATLAB ci fornisce delle *function* che fanno al nostro caso.

Vediamo prima il **caso generale** in cui data una matrice $A$ vogliamo calcolare *tutti* i suoi autovalori, costruiamo da principio una *matrice simmetrica* per
cui possiamo sfruttare il **Teorema Spettrale** per interpretare i risultati:
```matlab
A = rand(10); % costruiamo una matrice casuale
A = A + A'; % e facciamo in modo che sia simmetrica
lambda = eig(A); % calcoliamo *tutti* gli autovalori
disp(lambda)
```
che ci restituisce il vettore:
```
-2.1767
-1.8198
-0.7091
-0.3270
-0.1747
 0.7953
 0.9842
 1.3664
 1.9277
 9.4423
```
per cui abbiamo ottenuto 10 autovalori reali.

Se guardiamo il manuale del comando `eig` leggiamo:
```
eig    Eigenvalues and eigenvectors.
   E = eig(A) produces a column vector E containing the eigenvalues of
   a square matrix A.

   [V,D] = eig(A) produces a diagonal matrix D of eigenvalues and
   a full matrix V whose columns are the corresponding eigenvectors  
   so that A*V = V*D.

   [V,D,W] = eig(A) also produces a full matrix W whose columns are the
   corresponding left eigenvectors so that W'*A = D*W'.
```
Possiamo quindi usarlo per ottenere anche le relativi matrici degli autovettori sinistri e destri per la matrice $A$, cioè le matrici $V$ e $W$ tali che:
```{math}
A V = V D, \quad W^T A = D W^T.
```
:::{danger}
MATLAB, e la maggior parte degli algoritmi che calcolano autovalori, non conoscono la forma canonica di Jordan e l'esistenza di matrici non diagonalizzabili. Per cui vi restituiranno sempre una diagonalizzazione, anche quando questa non esiste. Consideriamo ad esempio il blocco di Jordan:
```matlab
J = gallery('jordbloc',5)
[V,D,W] = eig(J)
```
Otteniamo le due matrici, senza *warning* o altro... tuttavia se calcoliamo
```matlab
cond(V)

ans =

   1.3009e+63
```
che è un **valore enorme** per una matrice $5 \times 5$. Questo ci deve far sospettare che c'è qualcosa che non va!
:::

Per calcolare direttamente il raggio spettrale della matrice $M^{-1}N$ non abbiamo in realtà la necessità di calcolare tutti gli autovalori della matrice e prendere il massimo. Possiamo accedere ad algoritmi che calcolano direttamente la quantità che ci interessa:
```matlab
A = gallery('poisson',5); % Discretizzazione del Laplaciano in 2D
M = diag(A); % A = M - N
N = M-A;     % N = M - A
rho = eigs(N,M,1,'largestabs');
disp(abs(rho))
```
che ci restituisce il valore `0.8660` per il raggio spettrale, cioè abbiamo trovato uno **splitting convergente**.

Vediamo il manuale del comando `eigs`.
```
eigs   Find a few eigenvalues and eigenvectors of a matrix
 D = eigs(A) returns a vector of A's 6 largest magnitude eigenvalues.
 A must be square and should be large and sparse.

 [...]

 eigs(A,K,SIGMA) and eigs(A,B,K,SIGMA) return K eigenvalues. If SIGMA is:

        'largestabs' or 'smallestabs' - largest or smallest magnitude
      'largestreal' or 'smallestreal' - largest or smallest real part
                       'bothendsreal' - K/2 values with largest and
                                        smallest real part, respectively
                                        (one more from largest if K is odd)

    For nonsymmetric problems, SIGMA can also be:
      'largestimag' or 'smallestimag' - largest or smallest imaginary part
                       'bothendsimag' - K/2 values with largest and
                                       smallest imaginary part, respectively
                                       (one more from largest if K is odd)

    If SIGMA is a real or complex scalar including 0, eigs finds the
    eigenvalues closest to SIGMA.

```
da cui leggiamo che quello che abbiamo chiesto a MATLAB di calcolare è un autovalore (`1`) di massimo valore assoluto (`'largestabs'`) che risolva il problema
```{math}
N \mathbf{v} = \lambda M \mathbf{v},
```
che, nel nostro caso, è equivalente alla richiesta
```{math}
M^{-1}N \mathbf{v} = \lambda \mathbf{v},
```
cioè quello che cercavamo. Problemi di questa forma sono detti **problemi generalizzati agli autovalori**, ma sono ben al di fuori degli obiettivi di questo corso.

:::{warning}
Tutte le volte che volete risolvere un problema agli autovalori con matrice $M^{1}N$ la soluzione opportuna è quella di usare la formulazione come problema generalizzato agli autovalori, sia da un punto di vista di stabilità numerica, sia da un punto di vista di velocità di esecuzione del codice.
:::
-->
</section>
<section id="metodo-di-jacobi">
<h2>Metodo di Jacobi<a class="headerlink" href="#metodo-di-jacobi" title="Link a questa intestazione">#</a></h2>
<p>Il primo metodo che vogliamo implementare è il <strong>metodo di Jacobi</strong>, questo è basato sullo splitting additivo per la matrice <span class="math notranslate nohighlight">\(A\)</span> con <span class="math notranslate nohighlight">\(A = D - N\)</span> dove <span class="math notranslate nohighlight">\(D\)</span> è la diagonale della matrice <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="admonition-teorema admonition">
<p class="admonition-title">Teorema</p>
<p>Una condizione sufficiente (ma <strong>non necessaria</strong>) affinché il metodo di Jacobi sia convergente è che la matrice <span class="math notranslate nohighlight">\(A\)</span> sia a diagonale strettamente dominante, oppure a diagonale dominante e irriducibile.</p>
</div>
<p>Per trasformare il metodo in qualcosa di applicabile dobbiamo accoppiarlo ad un <strong>criterio d’arresto</strong>. Come sempre possiamo guardare al <strong>residuo assoluto</strong> oppure a quello <strong>relativo</strong> in una norma prefissata. Poiché abbiamo deciso di guardare alla convergenza attraverso informazioni spettrali scelta più naturale (e predittiva) è quella di usare la norma <span class="math notranslate nohighlight">\(\|\cdot\|_ 2\)</span>.</p>
<div class="math notranslate nohighlight">
\[\|\mathbf{r}^{(k)}\|_2 = \| A \mathbf{x}^{(k)} - \mathbf{b}\|_2 \leq \varepsilon,\]</div>
<p>ovvero, rispettivamente</p>
<div class="math notranslate nohighlight">
\[\|\mathbf{r}^{(k)}\|_2 = \| A \mathbf{x}^{(k)} - \mathbf{b}\|_2 \leq \varepsilon \|\mathbf{r}^{(0)}\|_2,\]</div>
<p>dove <span class="math notranslate nohighlight">\(\varepsilon\)</span> è una tolleranza prefissata.</p>
<div class="admonition-esercizio admonition">
<p class="admonition-title">Esercizio</p>
<p>Si scriva una <em>function</em> che implementi il metodo di Jacobi per la soluzione di un sistema lineare <span class="math notranslate nohighlight">\(A \mathbf{x} = \mathbf{y}\)</span> entro una tolleranza <span class="math notranslate nohighlight">\(\varepsilon\)</span> sfruttando il seguente prototipo:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[x,res,it]<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">jacobi</span><span class="p">(</span>A,b,x,itmax,eps<span class="p">)</span><span class="w"></span>
<span class="c">%%JACOBI implementa il metodo di Jacobi per la soluzione del sistema A x = b</span><span class="w"></span>
<span class="c">%    INPUT:</span><span class="w"></span>
<span class="c">%     A matrice quadrata</span><span class="w"></span>
<span class="c">%     b termine destro del sistema lineare da risolvere</span><span class="w"></span>
<span class="c">%     x innesco della strategia iterativa</span><span class="w"></span>
<span class="c">%     itmax massimo numero di iterazioni lineari consentito</span><span class="w"></span>
<span class="c">%    OUTPUT</span><span class="w"></span>
<span class="c">%     x ultima soluzione calcolata dal metodo</span><span class="w"></span>
<span class="c">%     res vettore dei residui</span><span class="w"></span>
<span class="c">%     it numero di iterazioni</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Si implementi in maniera vettoriale, cioè <strong>senza</strong> usare cicli <code class="docutils literal notranslate"><span class="pre">for</span></code> per scorrere le righe della matrice.</p></li>
<li><p>Si usi il criterio d’arresto basato sull’errore relativo.</p></li>
</ul>
<p>Per <em>testare</em> il metodo si usi il seguente programma</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">gallery</span><span class="p">(</span><span class="s">&#39;poisson&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c">% Matrice di prova</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">ones</span><span class="p">(</span><span class="mi">10</span>^<span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">           </span><span class="c">% rhs vettore di 1</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">zeros</span><span class="p">(</span><span class="mi">10</span>^<span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c">% Tentativo iniziale vettore di 0</span><span class="w"></span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">it</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">jacobi</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mf">1e-6</span><span class="p">);</span><span class="w"></span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="nb">semilogy</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">it</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="s">&#39;o-&#39;</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s">&#39;Iterazione&#39;</span><span class="p">);</span><span class="w"></span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s">&#39;Residuo relativo&#39;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="metodo-di-gauss-seidel">
<h2>Metodo di Gauss-Seidel<a class="headerlink" href="#metodo-di-gauss-seidel" title="Link a questa intestazione">#</a></h2>
<aside class="margin sidebar">
<p class="sidebar-title">Avanti/Indietro</p>
<p>Si può utilizzare la stessa idea anche con la parte triangolare superiore <span class="math notranslate nohighlight">\(U\)</span> di <span class="math notranslate nohighlight">\(A\)</span>, in genere si distingue tra i due chiamandoli, rispettivamente, metodo di Gauss-Seidel in <em>avanti</em> (forward Gauss-Seidel) o all”<em>indietro</em> (backward Gauss-Seidel).</p>
</aside>
<p>Il secondo metodo di questo tipo che avete visto è il metodo di <strong>Gauss-Seidel</strong>,
per questo metodo la decomposizione additiva della matrice <span class="math notranslate nohighlight">\(A\)</span> è <span class="math notranslate nohighlight">\(A = L - N\)</span>, dove <span class="math notranslate nohighlight">\(L\)</span> è la parte triangolare inferiore della matrice <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="admonition-teorema admonition">
<p class="admonition-title">Teorema</p>
<p>Una condizione sufficiente (ma <strong>non necessaria</strong>) affinché il metodo di Gauss-Seidel sia convergente è che la matrice <span class="math notranslate nohighlight">\(A\)</span> sia a diagonale strettamente dominante, oppure una matrice simmetrica e definita positiva.</p>
</div>
<p>Possiamo sfruttare di nuovo il <em>residuo relativo</em> per definire il criterio d’arresto.</p>
<div class="admonition-esercizio admonition">
<p class="admonition-title">Esercizio</p>
<p>Si scriva una <em>function</em> che implementi il metodo di Gauss-Seidel in avanti per la soluzione di un sistema lineare <span class="math notranslate nohighlight">\(A \mathbf{x} = \mathbf{y}\)</span> entro una tolleranza <span class="math notranslate nohighlight">\(\varepsilon\)</span> sfruttando il seguente prototipo:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[x,res,it]<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">forwardgs</span><span class="p">(</span>A,b,x,itmax,eps<span class="p">)</span><span class="w"></span>
<span class="c">%%FORWARDGS implementa il metodo di Gauss-Seidel in avanti per la soluzione del</span><span class="w"></span>
<span class="c">% sistema A x = b</span><span class="w"></span>
<span class="c">%    INPUT:</span><span class="w"></span>
<span class="c">%     A matrice quadrata</span><span class="w"></span>
<span class="c">%     b termine destro del sistema lineare da risolvere</span><span class="w"></span>
<span class="c">%     x innesco della strategia iterativa</span><span class="w"></span>
<span class="c">%     itmax massimo numero di iterazioni lineari consentito</span><span class="w"></span>
<span class="c">%    OUTPUT</span><span class="w"></span>
<span class="c">%     x ultima soluzione calcolata dal metodo</span><span class="w"></span>
<span class="c">%     res vettore dei residui</span><span class="w"></span>
<span class="c">%     it numero di iterazioni</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Si implementi in maniera vettoriale, cioè <strong>senza</strong> usare cicli <code class="docutils literal notranslate"><span class="pre">for</span></code> per scorrere le righe della matrice.</p></li>
<li><p>Si utilizzi la funzione <code class="docutils literal notranslate"><span class="pre">forwardsolve</span></code> vista in <a class="reference internal" href="laboratorio6.html#forwardandbacwardsolve"><span class="std std-ref">Sostituzione in avanti e all’indietro</span></a>.</p></li>
<li><p>Si usi il criterio d’arresto basato sull’errore relativo.</p></li>
</ul>
<p>Per <em>testare</em> il metodo si usi il seguente programma</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">gallery</span><span class="p">(</span><span class="s">&#39;poisson&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c">% Matrice di prova</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">ones</span><span class="p">(</span><span class="mi">10</span>^<span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">           </span><span class="c">% rhs vettore di 1</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">zeros</span><span class="p">(</span><span class="mi">10</span>^<span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c">% Tentativo iniziale vettore di 0</span><span class="w"></span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">it</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">forwardgs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mf">1e-6</span><span class="p">);</span><span class="w"></span>

<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="nb">semilogy</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">it</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="s">&#39;o-&#39;</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s">&#39;Iterazione&#39;</span><span class="p">);</span><span class="w"></span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s">&#39;Residuo relativo&#39;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</section>
<section id="paragone-tra-i-due-metodi-e-velocita-di-convergenza">
<h2>Paragone tra i due metodi e velocità di convergenza<a class="headerlink" href="#paragone-tra-i-due-metodi-e-velocita-di-convergenza" title="Link a questa intestazione">#</a></h2>
<p>Adesso che abbiamo implementato i due diversi metodi possiamo fare un confronto delle loro prestazioni. Possiamo paragonare in primo luogo le due storie di convergenza guardando all’evoluzione dei residui:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">gallery</span><span class="p">(</span><span class="s">&#39;poisson&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c">% Matrice di prova</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">ones</span><span class="p">(</span><span class="mi">10</span>^<span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">           </span><span class="c">% rhs vettore di 1</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">zeros</span><span class="p">(</span><span class="mi">10</span>^<span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w">          </span><span class="c">% Tentativo iniziale vettore di 0</span><span class="w"></span>

<span class="p">[</span><span class="n">xjacobi</span><span class="p">,</span><span class="n">resjacobi</span><span class="p">,</span><span class="n">itjacobi</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">jacobi</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mf">1e-6</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">xforwardgs</span><span class="p">,</span><span class="n">resforwardgs</span><span class="p">,</span><span class="n">itforwardgs</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">forwardgs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mf">1e-6</span><span class="p">);</span><span class="w"></span>


<span class="nb">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="nb">semilogy</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">itjacobi</span><span class="p">,</span><span class="n">resjacobi</span><span class="p">,</span><span class="s">&#39;o-&#39;</span><span class="p">,</span><span class="k">...</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="p">:</span><span class="n">itforwardgs</span><span class="p">,</span><span class="n">resforwardgs</span><span class="p">,</span><span class="s">&#39;x-&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s">&#39;Iterazione&#39;</span><span class="p">);</span><span class="w"></span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s">&#39;Residuo&#39;</span><span class="p">);</span><span class="w"></span>
<span class="nb">legend</span><span class="p">({</span><span class="s">&#39;Jacobi&#39;</span><span class="p">,</span><span class="s">&#39;Gauss-Seidel (Forward)&#39;</span><span class="p">},</span><span class="k">...</span><span class="w"></span>
<span class="w">    </span><span class="s">&#39;Location&#39;</span><span class="p">,</span><span class="s">&#39;northeast&#39;</span><span class="p">,</span><span class="k">...</span><span class="w"></span>
<span class="w">    </span><span class="s">&#39;FontSize&#39;</span><span class="p">,</span><span class="mi">14</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Da cui osserviamo che il metodo di Gauss-Seidel (forward) impiega meno iterazioni per raggiungere la convergenza desiderata (<a class="reference internal" href="#gaussjac1"><span class="std std-numref">Fig. 9</span></a>).</p>
<figure class="align-default" id="gaussjac1">
<a class="reference internal image-reference" href="_images/gaussjacobicomparison1.png"><img alt="convergenza-metodi" src="_images/gaussjacobicomparison1.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9 </span><span class="caption-text">Evoluzione del residuo per i metodi di Jacobi e Gauss-Seidel.</span><a class="headerlink" href="#gaussjac1" title="Link a questa immagine">#</a></p>
</figcaption>
</figure>
<p>Possiamo indagare la cosa dal punto di vista teorico andando a guardare il raggio spettrale delle due matrici di iterazione, infatti</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">diag</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="n">A</span><span class="p">));</span><span class="w"> </span><span class="c">% Jacobi</span><span class="w"></span>
<span class="n">N</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="n">rhojacobi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">eigs</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;largestabs&#39;</span><span class="p">);</span><span class="w"></span>

<span class="n">M</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">tril</span><span class="p">(</span><span class="n">A</span><span class="p">);</span><span class="w"> </span><span class="c">% Gauss-Seidel (forward)</span><span class="w"></span>
<span class="n">N</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="n">rhoforwardgs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">eigs</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;largestabs&#39;</span><span class="p">);</span><span class="w"></span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">&#39;Il raggio spettrale per Jacobi è %f\n&#39;</span><span class="p">,</span><span class="nb">abs</span><span class="p">(</span><span class="n">rhojacobi</span><span class="p">));</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">&#39;Il raggio spettrale per Gauss-Seidel è %f\n&#39;</span><span class="p">,</span><span class="nb">abs</span><span class="p">(</span><span class="n">rhoforwardgs</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Da cui scopriamo che:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Il</span> <span class="n">raggio</span> <span class="n">spettrale</span> <span class="n">per</span> <span class="n">Jacobi</span> <span class="n">è</span> <span class="mf">0.959493</span>
<span class="n">Il</span> <span class="n">raggio</span> <span class="n">spettrale</span> <span class="n">per</span> <span class="n">Gauss</span><span class="o">-</span><span class="n">Seidel</span> <span class="n">è</span> <span class="mf">0.920627</span>
</pre></div>
</div>
<p>dunque Gauss-Seidel (forward) ha un tasso di riduzione del residuo minore e una convergenza più rapida.</p>
<p>Possiamo aggiungere delle istruzioni <code class="docutils literal notranslate"><span class="pre">tic</span></code> e <code class="docutils literal notranslate"><span class="pre">toc</span></code> per valutare anche il tempo impiegato dai due differenti metodi:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Il</span> <span class="n">tempo</span> <span class="n">per</span> <span class="n">Jacobi</span> <span class="n">è</span> <span class="mf">0.008983</span> <span class="n">s</span>
<span class="n">Il</span> <span class="n">tempo</span> <span class="n">per</span> <span class="n">Gauss</span><span class="o">-</span><span class="n">Seidel</span> <span class="n">è</span> <span class="mf">0.182575</span> <span class="n">s</span>
</pre></div>
</div>
<p>ovvero il metodo di Jacobi è in questo caso circa due ordini di grandezza più rapido. Tuttavia, se andiamo a sostituire la nostra implementazione della funzione <code class="docutils literal notranslate"><span class="pre">forwardsolve</span></code> con il <code class="docutils literal notranslate"><span class="pre">\</span></code> implementato da MATLAB scopriamo che:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Il</span> <span class="n">tempo</span> <span class="n">per</span> <span class="n">Jacobi</span> <span class="n">è</span> <span class="mf">0.008191</span> <span class="n">s</span>
<span class="n">Il</span> <span class="n">tempo</span> <span class="n">per</span> <span class="n">Gauss</span><span class="o">-</span><span class="n">Seidel</span> <span class="n">è</span> <span class="mf">0.004435</span> <span class="n">s</span>
</pre></div>
</div>
<p>ed ora Gauss-Seidel ha ampiamente recuperato su Jacobi. L”<strong>implementazione</strong> conta! Qui il vantaggio è dato dal fatto che la matrice <span class="math notranslate nohighlight">\(L\)</span> associata al problema di test che stiamo guardando è una matrice <em>a banda</em> i non-zeri non riempiono tutto il triangolo. Il codice di MATLAB è in grado di accorgersene e adatto l’algoritmo di soluzione in modo che se ne tenga conto.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="laboratorio8.html" title="precedente pagina">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">precedente</p>
            <p class="prev-next-title">Laboratorio 8 : Il Problema Lineare dei Minimi Quadrati</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="laboratorio10.html" title="successivo pagina">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">successivo</p>
        <p class="prev-next-title">Laboratorio 10a : Il Metodo di Bisezione</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By F. Durastante, L. Heltai, C. Pagliantini<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>